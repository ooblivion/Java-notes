package KuangJava.OOP;

import KuangJava.OOP.Multi.Person;
import KuangJava.OOP.Multi.Student;

public class ApplicationMulti {
    public static void main(String[] args) {

        //new了什么就是什么，一个对象的实际类型是去确定的
        //new Student();
        //new Person();

        //可以指向的引用类型不确定

        //父类的引用指向子类的类型（对象），需要有继承关系才不会报错
        //Java特性，可以通过父类new子类对象
        //Object是超类

        //子类Student能调用的方法都是自己的或者继承父类的
        Student s1 = new Student();
        //父类型Person，可以指向子类但是不能调用子类独有的方法
        Person s2 = new Student();  //向下转换
        Object s3 = new Student();
        //String s4 = new Student();

        //执行哪个run方法取决于右边new的哪个对象

        //方法都是执行子类的，属性是看左边

        //对象能执行哪些方法，主要看对象左边的类型，和右边的关系不大
        s2.run();//子类重写了父类的方法，就重写子类
        s1.run();
        s1.eat();
        ((Student) s2).eat(); //向上转型
        //要向下转型，必须先向上转型，证明这个子类是父类的子类
        //父类型，可以指向子类，但是不能调用子类独有的方法，也访问不了属性
        //s2.eat();
        //把s2的Person类型强制转换成Student类型，强制转换向上类型

    }
}
/*
有相同的方法名与参数类型才叫重写

感觉是父借子之手在堆上开辟了一块空间来储存父的东西

大概student是person，面对同一个事情可能会做出不同的反应，而不能调用子类特有的类，可能就是为了聚焦在同一件事情上不同的行为特征

多态是方法的多态，属性没有多态
深层理解：属性是静态数据，方法是动态的行为

多态的注意事项
1.多态是方法的多态，属性没有多态
2.父类和子类，有联系。类型不同的话强转会报 类型转换异常 ClassCastException!
3.多态的存在条件
    - 继承关系
    - 方法需要重写 不重写的话调用的都是各自的方法，就没有区别了
    - 父类的变量名/引用 指向的是子类，父类引用指向子类对象 Father f1 = new Son();
有些方法不能重写
    - static    方法 是静态方法，属于类，不属于实例
    - final     常量 被final修饰的无法改变，在常量池里面
    - privat    方法 被private修饰的是私有的，也不能重写

在类等级不同的层次中可以[分享/公用]一个[行为/方法]的名字，
然而不同层次中的每个类却各自按自己的需求来实现则个行为。当对象接受到发送给它的消息时，
根据对象所属于的类动态选用在该类中定义的实现算法

具体来说，可以[重写]，但是没有实现重写的目的，没有把父类的方法覆盖掉，调用的时候还是各自调用各自的
 */
