package KuangJava.OOP;

import KuangJava.OOP.Multi.Person;
import KuangJava.OOP.Multi.Student;

public class TypeTransmit {
    public static void main(String[] args) {
        //类型之间的转换 基本类型转换 高低 64 32 16 8
        //父类 子类

        //父类转换为子类 Person=>Student
        //高             低
        Person obj = new Student();

        //student.go;
        //执行不了

        //student将这个对象转换为student类型，我们就可以使用student类型的方法了
        //现在的是person类型，要转换成较低的student类型，高转低，强制转换

        //(Student)xxx alt+enter
        Student obj1 = (Student) obj;
        ((Student) obj).go();
        obj1.go();


        System.out.println("=======");

        //下转 子类转换为父类 可能丢失自己本来的一些方法
        Student student = new Student();
        student.go();
        Person test = student;
        ((Student)test).go();

    }
}
/*
按继承图，自上而下，高是父类，低是子类

有问题才是正常的，有问题可以去搜父类应用指向子类内存图，去看本质原理就懂了

就是要拿儿子独有的对象要把对象老子类型强制将为儿子类型

就是父类用不了子类的方法，但是把自己伪装成子类（类型转化）就可以用了

记住一句话：编译看左，运行看右

业务上会出现这样的情况的，要结合多态的情况看，一个实例既要执行一个同名方法，还要执行独有的方法

低/子 转 高/父时，由于子已经继承了父类的所有，所以删去属于自己的然后自然而然的可以转化为父类
高/父 转 低/子时，则需要重新开辟只属于子类的空间，则需要用强制转换

父类不能调用子类的方法，子类可以调用父类的方法

子类引用不能指向父类对象

子类转父类，引用的时候无法使用子类独特的方法

1.父类引用指向子类的对象
2.把子类转换为父类，要向上转型，不用强制转换
3.把父类转化为子类，向下转型，需要强制转换，可能会丢失一些子类特有的方法，不是很好。
4.方便方法的调用，减少重复的代码，提高代码的利用率使代码更简洁
抽象 封装 继承 多态         后面还会学 抽象类 接口

向下转型，会丢失子类没有重写的哪些父类的方法

父类强转子类才可以调用子类的方法，别不是丢失，不转换无法调用子类特有的方法，和丢失没有关系，
父类本身就不含子类特有方法，内存不够接受不了

子转父，向上转型，直接转，丢失子类种原本可以直接调用的特有方法
父转子，向下转型，强制转，丢失父类被子类所重写掉的方法

（会不会丢失方法要看父类和子类是怎么写的了）

本质  子转父都内存分析
转父  内存会丢失，和父类都编程1.0内存，0.5个特有方法内存丢失

子类转父类会丢失方法，而父类转子类需要强制转换。
就像高类型int转化为低类型的byte需要强制转换一样

子转父，可能丢失方法；父转子，可能损失精度

数据类型哪儿强制转换是可能溢出的，多态这儿刚好相反，自动转换的才可能被丢弃

作为儿子时一些特有的（不属于父亲应该有的或者说是父亲没有的），行为（方法）在其成为父亲后便被舍弃了，比如打游戏

简单写个啥管理系统基本上就懂了
 */